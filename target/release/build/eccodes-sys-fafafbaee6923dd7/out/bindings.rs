/* automatically generated by rust-bindgen */

use libc::{FILE, off_t};

pub const CODES_VERSION : :: std :: os :: raw :: c_int = 21205 ; pub const CODES_SECTION_PRODUCT : :: std :: os :: raw :: c_int = 1 ; pub const CODES_SECTION_GRID : :: std :: os :: raw :: c_int = 2 ; pub const CODES_SECTION_LOCAL : :: std :: os :: raw :: c_int = 4 ; pub const CODES_SECTION_DATA : :: std :: os :: raw :: c_int = 8 ; pub const CODES_SECTION_BITMAP : :: std :: os :: raw :: c_int = 16 ; pub const CODES_LOG_INFO : :: std :: os :: raw :: c_int = 0 ; pub const CODES_LOG_WARNING : :: std :: os :: raw :: c_int = 1 ; pub const CODES_LOG_ERROR : :: std :: os :: raw :: c_int = 2 ; pub const CODES_LOG_FATAL : :: std :: os :: raw :: c_int = 3 ; pub const CODES_LOG_DEBUG : :: std :: os :: raw :: c_int = 4 ; pub const CODES_TYPE_UNDEFINED : :: std :: os :: raw :: c_int = 0 ; pub const CODES_TYPE_LONG : :: std :: os :: raw :: c_int = 1 ; pub const CODES_TYPE_DOUBLE : :: std :: os :: raw :: c_int = 2 ; pub const CODES_TYPE_STRING : :: std :: os :: raw :: c_int = 3 ; pub const CODES_TYPE_BYTES : :: std :: os :: raw :: c_int = 4 ; pub const CODES_TYPE_SECTION : :: std :: os :: raw :: c_int = 5 ; pub const CODES_TYPE_LABEL : :: std :: os :: raw :: c_int = 6 ; pub const CODES_TYPE_MISSING : :: std :: os :: raw :: c_int = 7 ; pub const CODES_MISSING_LONG : :: std :: os :: raw :: c_long = 2147483647 ; pub const CODES_MISSING_DOUBLE : f64 = -10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000. ; pub const CODES_UTIL_SET_SPEC_FLAGS_ONLY_PACKING : :: std :: os :: raw :: c_int = 1 ; pub const CODES_DUMP_FLAG_READ_ONLY : :: std :: os :: raw :: c_int = 1 ; pub const CODES_DUMP_FLAG_DUMP_OK : :: std :: os :: raw :: c_int = 2 ; pub const CODES_DUMP_FLAG_VALUES : :: std :: os :: raw :: c_int = 4 ; pub const CODES_DUMP_FLAG_CODED : :: std :: os :: raw :: c_int = 8 ; pub const CODES_DUMP_FLAG_OCTECT : :: std :: os :: raw :: c_int = 16 ; pub const CODES_DUMP_FLAG_ALIASES : :: std :: os :: raw :: c_int = 32 ; pub const CODES_DUMP_FLAG_TYPE : :: std :: os :: raw :: c_int = 64 ; pub const CODES_DUMP_FLAG_HEXADECIMAL : :: std :: os :: raw :: c_int = 128 ; pub const CODES_DUMP_FLAG_NO_DATA : :: std :: os :: raw :: c_int = 256 ; pub const CODES_DUMP_FLAG_ALL_DATA : :: std :: os :: raw :: c_int = 512 ; pub const CODES_DUMP_FLAG_ALL_ATTRIBUTES : :: std :: os :: raw :: c_int = 1024 ; pub const CODES_NEAREST_SAME_GRID : :: std :: os :: raw :: c_int = 1 ; pub const CODES_NEAREST_SAME_DATA : :: std :: os :: raw :: c_int = 2 ; pub const CODES_NEAREST_SAME_POINT : :: std :: os :: raw :: c_int = 4 ; pub const CODES_KEYS_ITERATOR_ALL_KEYS : :: std :: os :: raw :: c_ulong = 0 ; pub const CODES_KEYS_ITERATOR_SKIP_READ_ONLY : :: std :: os :: raw :: c_ulong = 1 ; pub const CODES_KEYS_ITERATOR_SKIP_OPTIONAL : :: std :: os :: raw :: c_ulong = 2 ; pub const CODES_KEYS_ITERATOR_SKIP_EDITION_SPECIFIC : :: std :: os :: raw :: c_ulong = 4 ; pub const CODES_KEYS_ITERATOR_SKIP_CODED : :: std :: os :: raw :: c_ulong = 8 ; pub const CODES_KEYS_ITERATOR_SKIP_COMPUTED : :: std :: os :: raw :: c_ulong = 16 ; pub const CODES_KEYS_ITERATOR_SKIP_DUPLICATES : :: std :: os :: raw :: c_ulong = 32 ; pub const CODES_KEYS_ITERATOR_SKIP_FUNCTION : :: std :: os :: raw :: c_ulong = 64 ; pub const CODES_KEYS_ITERATOR_DUMP_ONLY : :: std :: os :: raw :: c_ulong = 128 ; pub const CODES_UTIL_GRID_SPEC_REGULAR_LL : :: std :: os :: raw :: c_int = 1 ; pub const CODES_UTIL_GRID_SPEC_ROTATED_LL : :: std :: os :: raw :: c_int = 2 ; pub const CODES_UTIL_GRID_SPEC_REGULAR_GG : :: std :: os :: raw :: c_int = 3 ; pub const CODES_UTIL_GRID_SPEC_ROTATED_GG : :: std :: os :: raw :: c_int = 4 ; pub const CODES_UTIL_GRID_SPEC_REDUCED_GG : :: std :: os :: raw :: c_int = 5 ; pub const CODES_UTIL_GRID_SPEC_SH : :: std :: os :: raw :: c_int = 6 ; pub const CODES_UTIL_GRID_SPEC_REDUCED_LL : :: std :: os :: raw :: c_int = 7 ; pub const CODES_UTIL_GRID_SPEC_POLAR_STEREOGRAPHIC : :: std :: os :: raw :: c_int = 8 ; pub const CODES_UTIL_PACKING_TYPE_SPECTRAL_COMPLEX : :: std :: os :: raw :: c_int = 1 ; pub const CODES_UTIL_PACKING_TYPE_SPECTRAL_SIMPLE : :: std :: os :: raw :: c_int = 2 ; pub const CODES_UTIL_PACKING_TYPE_JPEG : :: std :: os :: raw :: c_int = 3 ; pub const CODES_UTIL_PACKING_TYPE_GRID_COMPLEX : :: std :: os :: raw :: c_int = 4 ; pub const CODES_UTIL_PACKING_TYPE_GRID_SIMPLE : :: std :: os :: raw :: c_int = 5 ; pub const CODES_UTIL_PACKING_TYPE_GRID_SIMPLE_MATRIX : :: std :: os :: raw :: c_int = 6 ; pub const CODES_UTIL_PACKING_TYPE_GRID_SECOND_ORDER : :: std :: os :: raw :: c_int = 7 ; pub const CODES_UTIL_PACKING_SAME_AS_INPUT : :: std :: os :: raw :: c_int = 0 ; pub const CODES_UTIL_PACKING_USE_PROVIDED : :: std :: os :: raw :: c_int = 1 ; pub const CODES_UTIL_ACCURACY_SAME_BITS_PER_VALUES_AS_INPUT : :: std :: os :: raw :: c_int = 0 ; pub const CODES_UTIL_ACCURACY_USE_PROVIDED_BITS_PER_VALUES : :: std :: os :: raw :: c_int = 1 ; pub const CODES_UTIL_ACCURACY_SAME_DECIMAL_SCALE_FACTOR_AS_INPUT : :: std :: os :: raw :: c_int = 2 ; pub const CODES_UTIL_ACCURACY_USE_PROVIDED_DECIMAL_SCALE_FACTOR : :: std :: os :: raw :: c_int = 3 ; pub const CODES_SUCCESS : :: std :: os :: raw :: c_int = 0 ; pub const CODES_END_OF_FILE : :: std :: os :: raw :: c_int = -1 ; pub const CODES_INTERNAL_ERROR : :: std :: os :: raw :: c_int = -2 ; pub const CODES_BUFFER_TOO_SMALL : :: std :: os :: raw :: c_int = -3 ; pub const CODES_NOT_IMPLEMENTED : :: std :: os :: raw :: c_int = -4 ; pub const CODES_7777_NOT_FOUND : :: std :: os :: raw :: c_int = -5 ; pub const CODES_ARRAY_TOO_SMALL : :: std :: os :: raw :: c_int = -6 ; pub const CODES_FILE_NOT_FOUND : :: std :: os :: raw :: c_int = -7 ; pub const CODES_CODE_NOT_FOUND_IN_TABLE : :: std :: os :: raw :: c_int = -8 ; pub const CODES_WRONG_ARRAY_SIZE : :: std :: os :: raw :: c_int = -9 ; pub const CODES_NOT_FOUND : :: std :: os :: raw :: c_int = -10 ; pub const CODES_IO_PROBLEM : :: std :: os :: raw :: c_int = -11 ; pub const CODES_INVALID_MESSAGE : :: std :: os :: raw :: c_int = -12 ; pub const CODES_DECODING_ERROR : :: std :: os :: raw :: c_int = -13 ; pub const CODES_ENCODING_ERROR : :: std :: os :: raw :: c_int = -14 ; pub const CODES_NO_MORE_IN_SET : :: std :: os :: raw :: c_int = -15 ; pub const CODES_GEOCALCULUS_PROBLEM : :: std :: os :: raw :: c_int = -16 ; pub const CODES_OUT_OF_MEMORY : :: std :: os :: raw :: c_int = -17 ; pub const CODES_READ_ONLY : :: std :: os :: raw :: c_int = -18 ; pub const CODES_INVALID_ARGUMENT : :: std :: os :: raw :: c_int = -19 ; pub const CODES_NULL_HANDLE : :: std :: os :: raw :: c_int = -20 ; pub const CODES_INVALID_SECTION_NUMBER : :: std :: os :: raw :: c_int = -21 ; pub const CODES_VALUE_CANNOT_BE_MISSING : :: std :: os :: raw :: c_int = -22 ; pub const CODES_WRONG_LENGTH : :: std :: os :: raw :: c_int = -23 ; pub const CODES_INVALID_TYPE : :: std :: os :: raw :: c_int = -24 ; pub const CODES_WRONG_STEP : :: std :: os :: raw :: c_int = -25 ; pub const CODES_WRONG_STEP_UNIT : :: std :: os :: raw :: c_int = -26 ; pub const CODES_INVALID_FILE : :: std :: os :: raw :: c_int = -27 ; pub const CODES_INVALID_GRIB : :: std :: os :: raw :: c_int = -28 ; pub const CODES_INVALID_INDEX : :: std :: os :: raw :: c_int = -29 ; pub const CODES_INVALID_ITERATOR : :: std :: os :: raw :: c_int = -30 ; pub const CODES_INVALID_KEYS_ITERATOR : :: std :: os :: raw :: c_int = -31 ; pub const CODES_INVALID_NEAREST : :: std :: os :: raw :: c_int = -32 ; pub const CODES_INVALID_ORDERBY : :: std :: os :: raw :: c_int = -33 ; pub const CODES_MISSING_KEY : :: std :: os :: raw :: c_int = -34 ; pub const CODES_OUT_OF_AREA : :: std :: os :: raw :: c_int = -35 ; pub const CODES_CONCEPT_NO_MATCH : :: std :: os :: raw :: c_int = -36 ; pub const CODES_HASH_ARRAY_NO_MATCH : :: std :: os :: raw :: c_int = -37 ; pub const CODES_NO_DEFINITIONS : :: std :: os :: raw :: c_int = -38 ; pub const CODES_WRONG_TYPE : :: std :: os :: raw :: c_int = -39 ; pub const CODES_END : :: std :: os :: raw :: c_int = -40 ; pub const CODES_NO_VALUES : :: std :: os :: raw :: c_int = -41 ; pub const CODES_WRONG_GRID : :: std :: os :: raw :: c_int = -42 ; pub const CODES_END_OF_INDEX : :: std :: os :: raw :: c_int = -43 ; pub const CODES_NULL_INDEX : :: std :: os :: raw :: c_int = -44 ; pub const CODES_PREMATURE_END_OF_FILE : :: std :: os :: raw :: c_int = -45 ; pub const CODES_INTERNAL_ARRAY_TOO_SMALL : :: std :: os :: raw :: c_int = -46 ; pub const CODES_MESSAGE_TOO_LARGE : :: std :: os :: raw :: c_int = -47 ; pub const CODES_CONSTANT_FIELD : :: std :: os :: raw :: c_int = -48 ; pub const CODES_SWITCH_NO_MATCH : :: std :: os :: raw :: c_int = -49 ; pub const CODES_UNDERFLOW : :: std :: os :: raw :: c_int = -50 ; pub const CODES_MESSAGE_MALFORMED : :: std :: os :: raw :: c_int = -51 ; pub const CODES_CORRUPTED_INDEX : :: std :: os :: raw :: c_int = -52 ; pub const CODES_INVALID_BPV : :: std :: os :: raw :: c_int = -53 ; pub const CODES_DIFFERENT_EDITION : :: std :: os :: raw :: c_int = -54 ; pub const CODES_VALUE_DIFFERENT : :: std :: os :: raw :: c_int = -55 ; pub const CODES_INVALID_KEY_VALUE : :: std :: os :: raw :: c_int = -56 ; pub const CODES_STRING_TOO_SMALL : :: std :: os :: raw :: c_int = -57 ; pub const CODES_WRONG_CONVERSION : :: std :: os :: raw :: c_int = -58 ; pub const CODES_MISSING_BUFR_ENTRY : :: std :: os :: raw :: c_int = -59 ; pub const CODES_NULL_POINTER : :: std :: os :: raw :: c_int = -60 ; pub const CODES_ATTRIBUTE_CLASH : :: std :: os :: raw :: c_int = -61 ; pub const CODES_TOO_MANY_ATTRIBUTES : :: std :: os :: raw :: c_int = -62 ; pub const CODES_ATTRIBUTE_NOT_FOUND : :: std :: os :: raw :: c_int = -63 ; pub const CODES_UNSUPPORTED_EDITION : :: std :: os :: raw :: c_int = -64 ; pub const CODES_OUT_OF_RANGE : :: std :: os :: raw :: c_int = -65 ; pub const CODES_WRONG_BITMAP_SIZE : :: std :: os :: raw :: c_int = -66 ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum ProductKind { PRODUCT_ANY = 0 , PRODUCT_GRIB = 1 , PRODUCT_BUFR = 2 , PRODUCT_METAR = 3 , PRODUCT_GTS = 4 , PRODUCT_TAF = 5 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_key_value_list { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_values { pub name : * const :: std :: os :: raw :: c_char , pub type_ : :: std :: os :: raw :: c_int , pub long_value : :: std :: os :: raw :: c_long , pub double_value : f64 , pub string_value : * const :: std :: os :: raw :: c_char , pub error : :: std :: os :: raw :: c_int , pub has_value : :: std :: os :: raw :: c_int , pub equal : :: std :: os :: raw :: c_int , pub next : * mut grib_values , } # [ test ] fn bindgen_test_layout_grib_values ( ) { assert_eq ! ( :: std :: mem :: size_of :: < grib_values > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( grib_values ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < grib_values > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( grib_values ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_values ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( grib_values ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_values ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( grib_values ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_values ) ) . long_value as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( grib_values ) , "::" , stringify ! ( long_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_values ) ) . double_value as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( grib_values ) , "::" , stringify ! ( double_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_values ) ) . string_value as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( grib_values ) , "::" , stringify ! ( string_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_values ) ) . error as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( grib_values ) , "::" , stringify ! ( error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_values ) ) . has_value as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( grib_values ) , "::" , stringify ! ( has_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_values ) ) . equal as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( grib_values ) , "::" , stringify ! ( equal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_values ) ) . next as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( grib_values ) , "::" , stringify ! ( next ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_handle { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_multi_handle { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_context { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_iterator { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_nearest { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_box { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_keys_iterator { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct bufr_keys_iterator { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_fieldset { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_order_by { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_where { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_sarray { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_oarray { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_darray { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_iarray { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_vdarray { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_vsarray { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_viarray { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_index { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_string_list { pub value : * mut :: std :: os :: raw :: c_char , pub count : :: std :: os :: raw :: c_int , pub next : * mut grib_string_list , } # [ test ] fn bindgen_test_layout_grib_string_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < grib_string_list > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( grib_string_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < grib_string_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( grib_string_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_string_list ) ) . value as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( grib_string_list ) , "::" , stringify ! ( value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_string_list ) ) . count as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( grib_string_list ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_string_list ) ) . next as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( grib_string_list ) , "::" , stringify ! ( next ) ) ) ; } extern "C" {
 pub fn codes_bufr_keys_iterator_new ( h : * mut grib_handle , filter_flags : :: std :: os :: raw :: c_ulong , ) -> * mut bufr_keys_iterator ; 
} extern "C" {
 pub fn codes_bufr_data_section_keys_iterator_new ( h : * mut grib_handle , ) -> * mut bufr_keys_iterator ; 
} extern "C" {
 pub fn codes_bufr_keys_iterator_next ( kiter : * mut bufr_keys_iterator , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_bufr_keys_iterator_get_name ( kiter : * mut bufr_keys_iterator , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn codes_bufr_keys_iterator_delete ( kiter : * mut bufr_keys_iterator , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_bufr_keys_iterator_rewind ( kiter : * mut bufr_keys_iterator , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_copy_key ( h1 : * mut grib_handle , h2 : * mut grib_handle , key : * const :: std :: os :: raw :: c_char , type_ : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_points { pub context : * mut grib_context , pub latitudes : * mut f64 , pub longitudes : * mut f64 , pub indexes : * mut usize , pub group_start : * mut usize , pub group_len : * mut usize , pub n_groups : usize , pub n : usize , pub size : usize , } # [ test ] fn bindgen_test_layout_grib_points ( ) { assert_eq ! ( :: std :: mem :: size_of :: < grib_points > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( grib_points ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < grib_points > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( grib_points ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_points ) ) . context as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( grib_points ) , "::" , stringify ! ( context ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_points ) ) . latitudes as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( grib_points ) , "::" , stringify ! ( latitudes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_points ) ) . longitudes as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( grib_points ) , "::" , stringify ! ( longitudes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_points ) ) . indexes as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( grib_points ) , "::" , stringify ! ( indexes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_points ) ) . group_start as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( grib_points ) , "::" , stringify ! ( group_start ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_points ) ) . group_len as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( grib_points ) , "::" , stringify ! ( group_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_points ) ) . n_groups as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( grib_points ) , "::" , stringify ! ( n_groups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_points ) ) . n as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( grib_points ) , "::" , stringify ! ( n ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_points ) ) . size as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( grib_points ) , "::" , stringify ! ( size ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct grib_util_grid_spec { pub grid_type : :: std :: os :: raw :: c_int , pub Ni : :: std :: os :: raw :: c_long , pub Nj : :: std :: os :: raw :: c_long , pub iDirectionIncrementInDegrees : f64 , pub jDirectionIncrementInDegrees : f64 , pub longitudeOfFirstGridPointInDegrees : f64 , pub longitudeOfLastGridPointInDegrees : f64 , pub latitudeOfFirstGridPointInDegrees : f64 , pub latitudeOfLastGridPointInDegrees : f64 , pub uvRelativeToGrid : :: std :: os :: raw :: c_long , pub latitudeOfSouthernPoleInDegrees : f64 , pub longitudeOfSouthernPoleInDegrees : f64 , pub iScansNegatively : :: std :: os :: raw :: c_long , pub jScansPositively : :: std :: os :: raw :: c_long , pub N : :: std :: os :: raw :: c_long , pub bitmapPresent : :: std :: os :: raw :: c_long , pub missingValue : f64 , pub pl : * const :: std :: os :: raw :: c_long , pub pl_size : :: std :: os :: raw :: c_long , pub truncation : :: std :: os :: raw :: c_long , pub orientationOfTheGridInDegrees : f64 , pub DyInMetres : :: std :: os :: raw :: c_long , pub DxInMetres : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_grib_util_grid_spec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < grib_util_grid_spec > ( ) , 184usize , concat ! ( "Size of: " , stringify ! ( grib_util_grid_spec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < grib_util_grid_spec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( grib_util_grid_spec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . grid_type as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( grid_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . Ni as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( Ni ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . Nj as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( Nj ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . iDirectionIncrementInDegrees as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( iDirectionIncrementInDegrees ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . jDirectionIncrementInDegrees as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( jDirectionIncrementInDegrees ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . longitudeOfFirstGridPointInDegrees as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( longitudeOfFirstGridPointInDegrees ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . longitudeOfLastGridPointInDegrees as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( longitudeOfLastGridPointInDegrees ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . latitudeOfFirstGridPointInDegrees as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( latitudeOfFirstGridPointInDegrees ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . latitudeOfLastGridPointInDegrees as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( latitudeOfLastGridPointInDegrees ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . uvRelativeToGrid as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( uvRelativeToGrid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . latitudeOfSouthernPoleInDegrees as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( latitudeOfSouthernPoleInDegrees ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . longitudeOfSouthernPoleInDegrees as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( longitudeOfSouthernPoleInDegrees ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . iScansNegatively as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( iScansNegatively ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . jScansPositively as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( jScansPositively ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . N as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( N ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . bitmapPresent as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( bitmapPresent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . missingValue as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( missingValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . pl as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( pl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . pl_size as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( pl_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . truncation as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( truncation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . orientationOfTheGridInDegrees as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( orientationOfTheGridInDegrees ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . DyInMetres as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( DyInMetres ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_grid_spec ) ) . DxInMetres as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_grid_spec ) , "::" , stringify ! ( DxInMetres ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct grib_util_packing_spec { pub packing_type : :: std :: os :: raw :: c_long , pub packing : :: std :: os :: raw :: c_long , pub boustrophedonic : :: std :: os :: raw :: c_long , pub editionNumber : :: std :: os :: raw :: c_long , pub accuracy : :: std :: os :: raw :: c_long , pub bitsPerValue : :: std :: os :: raw :: c_long , pub decimalScaleFactor : :: std :: os :: raw :: c_long , pub computeLaplacianOperator : :: std :: os :: raw :: c_long , pub truncateLaplacian : :: std :: os :: raw :: c_int , pub laplacianOperator : f64 , pub deleteLocalDefinition : :: std :: os :: raw :: c_long , pub extra_settings : [ grib_values ; 80usize ] , pub extra_settings_count : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_grib_util_packing_spec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < grib_util_packing_spec > ( ) , 5216usize , concat ! ( "Size of: " , stringify ! ( grib_util_packing_spec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < grib_util_packing_spec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( grib_util_packing_spec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . packing_type as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( packing_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . packing as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( packing ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . boustrophedonic as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( boustrophedonic ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . editionNumber as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( editionNumber ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . accuracy as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( accuracy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . bitsPerValue as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( bitsPerValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . decimalScaleFactor as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( decimalScaleFactor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . computeLaplacianOperator as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( computeLaplacianOperator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . truncateLaplacian as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( truncateLaplacian ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . laplacianOperator as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( laplacianOperator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . deleteLocalDefinition as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( deleteLocalDefinition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . extra_settings as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( extra_settings ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const grib_util_packing_spec ) ) . extra_settings_count as * const _ as usize } , 5208usize , concat ! ( "Alignment of field: " , stringify ! ( grib_util_packing_spec ) , "::" , stringify ! ( extra_settings_count ) ) ) ; } pub type codes_assertion_failed_proc = :: std :: option :: Option < unsafe extern "C" fn ( message : * const :: std :: os :: raw :: c_char ) > ; extern "C" {
 pub fn codes_set_codes_assertion_failed_proc ( proc_ : codes_assertion_failed_proc , ) ; 
} pub type codes_values = grib_values ; pub type codes_key_value_list = grib_key_value_list ; 
 /// Codes handle,   structure giving access to parsed values by keys
/// \ingroup codes_handle
/// \struct codes_handle 
 pub type codes_handle = grib_handle ; 
 /// GRIB multi field handle,   structure used to build multi fields messages.
/// \ingroup codes_handle
/// \struct codes_multi_handle 
 pub type codes_multi_handle = grib_multi_handle ; 
 /// Codes context,  structure containing the memory methods, the parsers and the formats.
/// \ingroup codes_context
/// \struct codes_context 
 pub type codes_context = grib_context ; 
 /// Codes iterator, structure supporting a geographic iteration of values in a GRIB message.
/// \ingroup iterators
/// \struct codes_iterator 
 pub type codes_iterator = grib_iterator ; 
 /// Codes nearest, structure used to find the nearest points of a latitude longitude point in a GRIB message.
/// \ingroup iterators
/// \struct codes_nearest 
 pub type codes_nearest = grib_nearest ; pub type codes_box = grib_box ; pub type codes_points = grib_points ; 
 /// Codes keys iterator. Iterator over keys.
/// \ingroup keys_iterator
/// \struct codes_keys_iterator 
 pub type codes_keys_iterator = grib_keys_iterator ; pub type codes_bufr_keys_iterator = bufr_keys_iterator ; pub type codes_fieldset = grib_fieldset ; pub type codes_order_by = grib_order_by ; pub type codes_where = grib_where ; pub type codes_sarray = grib_sarray ; pub type codes_oarray = grib_oarray ; pub type codes_darray = grib_darray ; pub type codes_iarray = grib_iarray ; pub type codes_vdarray = grib_vdarray ; pub type codes_vsarray = grib_vsarray ; pub type codes_viarray = grib_viarray ; pub type codes_string_list = grib_string_list ; pub type codes_util_packing_spec = grib_util_packing_spec ; pub type codes_util_grid_spec = grib_util_grid_spec ; extern "C" {
 pub fn codes_fieldset_new_from_files ( c : * mut codes_context , filenames : * mut * mut :: std :: os :: raw :: c_char , nfiles : :: std :: os :: raw :: c_int , keys : * mut * mut :: std :: os :: raw :: c_char , nkeys : :: std :: os :: raw :: c_int , where_string : * const :: std :: os :: raw :: c_char , order_by_string : * const :: std :: os :: raw :: c_char , err : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_fieldset ; 
} extern "C" {
 pub fn codes_fieldset_delete ( set : * mut codes_fieldset , ) ; 
} extern "C" {
 pub fn codes_fieldset_rewind ( set : * mut codes_fieldset , ) ; 
} extern "C" {
 pub fn codes_fieldset_apply_order_by ( set : * mut codes_fieldset , order_by_string : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_fieldset_next_handle ( set : * mut codes_fieldset , err : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_handle ; 
} extern "C" {
 pub fn codes_fieldset_count ( set : * mut codes_fieldset , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_values_check ( h : * mut codes_handle , values : * mut codes_values , count : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} 
 /// index structure to access messages in a file.
/// \ingroup codes_index
/// \struct codes_index 
 pub type codes_index = grib_index ; extern "C" {
 
 /// Create a new index form a file. The file is indexed with the keys in argument.
///
/// @param c           : context  (NULL for default context)
/// @param filename    : name of the file of messages to be indexed
/// @param keys        : comma separated list of keys for the index.
/// The type of the key can be explicitly declared appending :l for long,
/// (or alternatively :i)
/// :d for double, :s for string to the key name. If the type is not
/// declared explicitly, the native type is assumed.
/// @param err         :  0 if OK, integer value on error
/// @return            the newly created index 
 
 pub fn codes_index_new_from_file ( c : * mut codes_context , filename : * mut :: std :: os :: raw :: c_char , keys : * const :: std :: os :: raw :: c_char , err : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_index ; 
} extern "C" {
 
 /// Create a new index based on a set of keys.
///
/// @param c           : context  (NULL for default context)
/// @param keys        : comma separated list of keys for the index.
/// The type of the key can be explicitly declared appending :l for long,
/// (or alternatively :i)
/// :d for double, :s for string to the key name. If the type is not
/// declared explicitly, the native type is assumed.
/// @param err         :  0 if OK, integer value on error
/// @return            the newly created index 
 
 pub fn codes_index_new ( c : * mut codes_context , keys : * const :: std :: os :: raw :: c_char , err : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_index ; 
} extern "C" {
 
 /// Indexes the file given in argument in the index given in argument.
///
/// @param index       : index
/// @param filename    : name of the file of messages to be indexed
/// @return            0 if OK, integer value on error 
 
 pub fn codes_index_add_file ( index : * mut grib_index , filename : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_index_write ( index : * mut codes_index , filename : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_index_read ( c : * mut codes_context , filename : * const :: std :: os :: raw :: c_char , err : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_index ; 
} extern "C" {
 
 /// Get the number of distinct values of the key in argument contained in the index. The key must belong to the index.
///
/// @param index       : an index created from a file.
/// The index must have been created with the key in argument.
/// @param key         : key for which the number of values is computed
/// @param size        : number of distinct values of the key in the index
/// @return            0 if OK, integer value on error 
 
 pub fn codes_index_get_size ( index : * mut codes_index , key : * const :: std :: os :: raw :: c_char , size : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get the distinct values of the key in argument contained in the index. The key must belong to the index. This function is used when the type of the key was explicitly defined as long or when the native type of the key is long.
///
/// @param index       : an index created from a file.
/// The index must have been created with the key in argument.
/// @param key         : key for which the values are returned
/// @param values      : array of values. The array must be allocated before entering this function and its size must be enough to contain all the values.
/// @param size        : size of the values array
/// @return            0 if OK, integer value on error 
 
 pub fn codes_index_get_long ( index : * mut codes_index , key : * const :: std :: os :: raw :: c_char , values : * mut :: std :: os :: raw :: c_long , size : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get the distinct values of the key in argument contained in the index. The key must belong to the index. This function is used when the type of the key was explicitly defined as double or when the native type of the key is double.
///
/// @param index       : an index created from a file.
/// The index must have been created with the key in argument.
/// @param key         : key for which the values are returned
/// @param values      : array of values. The array must be allocated before entering this function and its size must be enough to contain all the values.
/// @param size        : size of the values array
/// @return            0 if OK, integer value on error 
 
 pub fn codes_index_get_double ( index : * mut codes_index , key : * const :: std :: os :: raw :: c_char , values : * mut f64 , size : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get the distinct values of the key in argument contained in the index. The key must belong to the index. This function is used when the type of the key was explicitly defined as string or when the native type of the key is string.
///
/// @param index       : an index created from a file.
/// The index must have been created with the key in argument.
/// @param key         : key for which the values are returned
/// @param values      : array of values. The array must be allocated before entering this function and its size must be enough to contain all the values.
/// @param size        : size of the values array
/// @return            0 if OK, integer value on error 
 
 pub fn codes_index_get_string ( index : * mut codes_index , key : * const :: std :: os :: raw :: c_char , values : * mut * mut :: std :: os :: raw :: c_char , size : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Select the message subset with key==value. The value is a long. The key must have been created with long type or have long as native type if the type was not explicitly defined in the index creation.
///
/// @param index       : an index created from a file.
/// The index must have been created with the key in argument.
/// @param key         : key to be selected
/// @param value       : value of the key to select
/// @return            0 if OK, integer value on error 
 
 pub fn codes_index_select_long ( index : * mut codes_index , key : * const :: std :: os :: raw :: c_char , value : :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Select the message subset with key==value. The value is a double. The key must have been created with double type or have double as native type if the type was not explicitly defined in the index creation.
///
/// @param index       : an index created from a file.
/// The index must have been created with the key in argument.
/// @param key         : key to be selected
/// @param value       : value of the key to select
/// @return            0 if OK, integer value on error 
 
 pub fn codes_index_select_double ( index : * mut codes_index , key : * const :: std :: os :: raw :: c_char , value : f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Select the message subset with key==value. The value is a string. The key must have been created with string type or have string as native type if the type was not explicitly defined in the index creation.
///
/// @param index       : an index created from a file.
/// The index must have been created with the key in argument.
/// @param key         : key to be selected
/// @param value       : value of the key to select
/// @return            0 if OK, integer value on error 
 
 pub fn codes_index_select_string ( index : * mut codes_index , key : * const :: std :: os :: raw :: c_char , value : * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Create a new handle from an index after having selected the key values.
/// All the keys belonging to the index must be selected before calling this function. Successive calls to this function will return all the handles compatible with the constraints defined selecting the values of the index keys.
/// When no more handles are available from the index a NULL pointer is returned and the err variable is set to CODES_END_OF_INDEX.
///
/// @param index       : an index created from a file.
/// @param err         :  0 if OK, integer value on error. CODES_END_OF_INDEX when no more handles are contained in the index.
/// @return            grib handle. 
 
 pub fn codes_handle_new_from_index ( index : * mut codes_index , err : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_handle ; 
} extern "C" {
 
 /// Delete the index.
///
/// @param index       : index to be deleted. 
 
 pub fn codes_index_delete ( index : * mut codes_index , ) ; 
} extern "C" {
 
 /// \defgroup codes_handle The message handle
/// The codes_handle is the structure giving access to parsed message values by keys.
/// /
/// /*! @{*/
/// /**
/// Counts the messages contained in a file resource.
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param f           : the file resource
/// @param n           : the number of messages in the file
/// @return            0 if OK, integer value on error 
 
 pub fn codes_count_in_file ( c : * mut codes_context , f : * mut FILE , n : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Counts the messages contained in a file.
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param filename    : the path to the file
/// @param n           : the number of messages in the file
/// @return            0 if OK, integer value on error 
 
 pub fn codes_count_in_filename ( c : * mut codes_context , filename : * const :: std :: os :: raw :: c_char , n : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Create a handle from a file resource.
/// The file is read until a message is found. The message is then copied.
/// Remember always to delete the handle when it is not needed anymore to avoid
/// memory leaks.
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param f           : the file resource
/// @param product     : the kind of product e.g. PRODUCT_GRIB, PRODUCT_BUFR
/// @param error       : error code set if the returned handle is NULL and the end of file is not reached
/// @return            the new handle, NULL if the resource is invalid or a problem is encountered 
 
 pub fn codes_handle_new_from_file ( c : * mut grib_context , f : * mut FILE , product : ProductKind , error : * mut :: std :: os :: raw :: c_int , ) -> * mut grib_handle ; 
} extern "C" {
 
 /// Create a GRIB handle from a file resource.
/// The file is read until a GRIB message is found. The message is then copied.
/// Remember always to delete the handle when it is not needed anymore to avoid
/// memory leaks.
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param f           : the file resource
/// @param error       : error code set if the returned handle is NULL and the end of file is not reached
/// @return            the new handle, NULL if the resource is invalid or a problem is encountered 
 
 pub fn codes_grib_handle_new_from_file ( c : * mut grib_context , f : * mut FILE , error : * mut :: std :: os :: raw :: c_int , ) -> * mut grib_handle ; 
} extern "C" {
 
 /// Create a BUFR handle from a file resource.
/// The file is read until a BUFR message is found. The message is then copied.
/// Remember always to delete the handle when it is not needed anymore to avoid
/// memory leaks.
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param f           : the file resource
/// @param error       : error code set if the returned handle is NULL and the end of file is not reached
/// @return            the new handle, NULL if the resource is invalid or a problem is encountered 
 
 pub fn codes_bufr_handle_new_from_file ( c : * mut grib_context , f : * mut FILE , error : * mut :: std :: os :: raw :: c_int , ) -> * mut grib_handle ; 
} extern "C" {
 
 /// Write a coded message to a file.
///
/// @param h           : codes_handle to be written
/// @param file        : name of the output file
/// @param mode        : mode
/// @return            0 if OK, integer value on error 
 
 pub fn codes_write_message ( h : * mut codes_handle , file : * const :: std :: os :: raw :: c_char , mode : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_grib_util_sections_copy ( hfrom : * mut codes_handle , hto : * mut codes_handle , what : :: std :: os :: raw :: c_int , err : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_handle ; 
} extern "C" {
 pub fn codes_grib_util_get_param_id ( mars_param : * const :: std :: os :: raw :: c_char , ) -> * mut codes_string_list ; 
} extern "C" {
 pub fn codes_grib_util_get_mars_param ( param_id : * const :: std :: os :: raw :: c_char , ) -> * mut codes_string_list ; 
} extern "C" {
 
 /// Create a handle from a user message in memory. The message will not be freed at the end.
/// The message will be copied as soon as a modification is needed.
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param data        : the actual message
/// @param data_len    : the length of the message in number of bytes
/// @return            the new handle, NULL if the message is invalid or a problem is encountered 
 
 pub fn codes_handle_new_from_message ( c : * mut codes_context , data : * const :: std :: os :: raw :: c_void , data_len : usize , ) -> * mut codes_handle ; 
} extern "C" {
 
 /// Create a handle from a user message in memory. The message will not be freed at the end.
/// The message will be copied as soon as a modification is needed.
/// This function works also with multi field messages.
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param data        : the actual message
/// @param data_len    : the length of the message in number of bytes
/// @param error       : error code
/// @return            the new handle, NULL if the message is invalid or a problem is encountered 
 
 pub fn codes_grib_handle_new_from_multi_message ( c : * mut codes_context , data : * mut * mut :: std :: os :: raw :: c_void , data_len : * mut usize , error : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_handle ; 
} extern "C" {
 
 /// Create a handle from a user message. The message is copied and will be freed with the handle
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param data        : the actual message
/// @param data_len    : the length of the message in number of bytes
/// @return            the new handle, NULL if the message is invalid or a problem is encountered 
 
 pub fn codes_handle_new_from_message_copy ( c : * mut codes_context , data : * const :: std :: os :: raw :: c_void , data_len : usize , ) -> * mut codes_handle ; 
} extern "C" {
 
 /// Create a handle from a GRIB message contained in the samples directory.
/// The message is copied at the creation of the handle
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param sample_name : the name of the sample file (without the .tmpl extension)
/// @return            the new handle, NULL if the resource is invalid or a problem is encountered 
 
 pub fn codes_grib_handle_new_from_samples ( c : * mut codes_context , sample_name : * const :: std :: os :: raw :: c_char , ) -> * mut codes_handle ; 
} extern "C" {
 
 /// Create a handle from a BUFR message contained in a samples directory.
/// The message is copied at the creation of the handle
///
/// @param c           : the context from which the handle will be created (NULL for default context)
/// @param sample_name : the name of the sample file (without the .tmpl extension)
/// @return            the new handle, NULL if the resource is invalid or a problem is encountered 
 
 pub fn codes_bufr_handle_new_from_samples ( c : * mut codes_context , sample_name : * const :: std :: os :: raw :: c_char , ) -> * mut codes_handle ; 
} extern "C" {
 
 /// Clone an existing handle using the context of the original handle,
/// The message is copied and reparsed
///
/// @param h           : The handle to be cloned
/// @return            the new handle, NULL if the message is invalid or a problem is encountered 
 
 pub fn codes_handle_clone ( h : * mut codes_handle , ) -> * mut codes_handle ; 
} extern "C" {
 
 /// Frees a handle, also frees the message if it is not a user message
/// @see  codes_handle_new_from_message
/// @param h           : The handle to be deleted
/// @return            0 if OK, integer value on error 
 
 pub fn codes_handle_delete ( h : * mut codes_handle , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Create an empty multi-field GRIB handle.
/// Remember always to delete the multi-handle when it is not needed any more to avoid
/// memory leaks.
///
/// @param c           : the context from which the handle will be created (NULL for default context) 
 
 pub fn codes_grib_multi_handle_new ( c : * mut codes_context , ) -> * mut codes_multi_handle ; 
} extern "C" {
 
 /// Append the sections starting with start_section of the message pointed by h at
/// the end of the multi-field GRIB handle mh.
/// Remember always to delete the multi-handle when it is not needed any more to avoid
/// memory leaks.
///
/// @param h           : The handle from which the sections are copied.
/// @param start_section : section number. Starting from this section all the sections to the end of the message will be copied.
/// @param mh          : The multi-field handle on which the sections are appended.
/// @return            0 if OK, integer value on error 
 
 pub fn codes_grib_multi_handle_append ( h : * mut codes_handle , start_section : :: std :: os :: raw :: c_int , mh : * mut codes_multi_handle , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Delete multi-field GRIB handle.
///
/// @param mh          : The multi-field handle to be deleted.
/// @return            0 if OK, integer value on error 
 
 pub fn codes_grib_multi_handle_delete ( mh : * mut codes_multi_handle , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Write a multi-field GRIB handle in a file.
/// Remember always to delete the multi-handle when it is not needed any more to avoid
/// memory leaks.
///
/// @param mh          : The multi-field GRIB handle to be written.
/// @param f            : File on which the file handle is written.
/// @return            0 if OK, integer value on error 
 
 pub fn codes_grib_multi_handle_write ( mh : * mut codes_multi_handle , f : * mut FILE , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \defgroup handling_coded_messages Handling coded messages */
/// /*! @{ */
/// /**
/// getting the message attached to a handle
///
/// @param h              : the handle to which the buffer should be gathered
/// @param message        : the pointer to be set to the handle's data
/// @param message_length : On exit, the message size in number of bytes
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_message ( h : * mut codes_handle , message : * mut * const :: std :: os :: raw :: c_void , message_length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// getting a copy of the message attached to a handle
///
/// @param h              : the handle to which the buffer should be returned
/// @param message        : the pointer to the data buffer to be filled
/// @param message_length : On entry, the size in number of bytes of the allocated empty message.
/// On exit, the actual message length in number of bytes
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_message_copy ( h : * mut codes_handle , message : * mut :: std :: os :: raw :: c_void , message_length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Create a new iterator from a GRIB handle, using current geometry and values.
///
/// \param h           : the handle from which the iterator will be created
/// \param flags       : flags for future use.
/// \param error       : error code
/// \return            the new iterator, NULL if no iterator can be created 
 
 pub fn codes_grib_iterator_new ( h : * mut codes_handle , flags : :: std :: os :: raw :: c_ulong , error : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_iterator ; 
} extern "C" {
 
 /// Get latitude/longitude and data values.
/// The Latitudes, longitudes and values arrays must be properly allocated by the caller.
/// Their required dimension can be obtained by getting the value of the integer key "numberOfPoints".
///
/// @param h           : handle from which geography and data values are taken
/// @param lats        : returned array of latitudes
/// @param lons        : returned array of longitudes
/// @param values      : returned array of data values
/// @return            0 if OK, integer value on error 
 
 pub fn codes_grib_get_data ( h : * mut codes_handle , lats : * mut f64 , lons : * mut f64 , values : * mut f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get the next value from an iterator.
///
/// @param i           : the iterator
/// @param lat         : on output latitude in degree
/// @param lon         : on output longitude in degree
/// @param value       : on output value of the point
/// @return            positive value if successful, 0 if no more data are available 
 
 pub fn codes_grib_iterator_next ( i : * mut codes_iterator , lat : * mut f64 , lon : * mut f64 , value : * mut f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get the previous value from an iterator.
///
/// @param i           : the iterator
/// @param lat         : on output latitude in degree
/// @param lon         : on output longitude in degree
/// @param value       : on output value of the point*
/// @return            positive value if successful, 0 if no more data are available 
 
 pub fn codes_grib_iterator_previous ( i : * mut codes_iterator , lat : * mut f64 , lon : * mut f64 , value : * mut f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Test procedure for values in an iterator.
///
/// @param i           : the iterator
/// @return            boolean, 1 if the iterator still nave next values, 0 otherwise 
 
 pub fn codes_grib_iterator_has_next ( i : * mut codes_iterator , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Test procedure for values in an iterator.
///
/// @param i           : the iterator
/// @return            0 if OK, integer value on error 
 
 pub fn codes_grib_iterator_reset ( i : * mut codes_iterator , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Frees an iterator from memory
///
/// @param i           : the iterator
/// @return            0 if OK, integer value on error 
 
 pub fn codes_grib_iterator_delete ( i : * mut codes_iterator , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Create a new nearest from a handle, using current geometry .
///
/// \param h           : the handle from which the iterator will be created
/// \param error       : error code
/// \return            the new nearest, NULL if no nearest can be created 
 
 pub fn codes_grib_nearest_new ( h : * mut codes_handle , error : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_nearest ; 
} extern "C" {
 
 /// Find the 4 nearest points of a latitude longitude point.
/// The flags are provided to speed up the process of searching. If you are
/// sure that the point you are asking for is not changing from a call
/// to another you can use CODES_NEAREST_SAME_POINT. The same is valid for
/// the grid. Flags can be used together doing a bitwise OR.
/// The distances are given in kilometres.
///
/// @param nearest     : nearest structure
/// @param h           : handle from which geography and data values are taken
/// @param inlat       : latitude of the point to search for
/// @param inlon       : longitude of the point to search for
/// @param flags       : CODES_NEAREST_SAME_POINT, CODES_NEAREST_SAME_GRID
/// @param outlats     : returned array of latitudes of the nearest points
/// @param outlons     : returned array of longitudes of the nearest points
/// @param values      : returned array of data values of the nearest points
/// @param distances   : returned array of distances from the nearest points
/// @param indexes     : returned array of indexes of the nearest points
/// @param len         : size of the arrays
/// @return            0 if OK, integer value on error 
 
 pub fn codes_grib_nearest_find ( nearest : * mut codes_nearest , h : * mut codes_handle , inlat : f64 , inlon : f64 , flags : :: std :: os :: raw :: c_ulong , outlats : * mut f64 , outlons : * mut f64 , values : * mut f64 , distances : * mut f64 , indexes : * mut :: std :: os :: raw :: c_int , len : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Frees an nearest from memory
///
/// @param nearest           : the nearest
/// @return            0 if OK, integer value on error 
 
 pub fn codes_grib_nearest_delete ( nearest : * mut codes_nearest , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Find the nearest point of a set of points whose latitudes and longitudes
/// are given in the inlats, inlons arrays respectively.
/// If the flag is_lsm is 1 the nearest land point is returned and the
/// grib passed as handle (h) is considered a land sea mask.
/// The land nearest point is the nearest point with land sea mask value>=0.5.
/// If no nearest land points are found the nearest value is returned.
/// If the flag is_lsm is 0 the nearest point is returned.
/// values, distances, indexes (in the "values" array) for the nearest points (ilons,ilats)
/// are returned.
/// The distances are given in kilometres.
///
/// @param h           : handle from which geography and data values are taken
/// @param is_lsm      : lsm flag (1-> nearest land, 0-> nearest)
/// @param inlats      : latitudes of the points to search for
/// @param inlons      : longitudes of the points to search for
/// @param npoints     : number of points (size of the inlats,inlons,outlats,outlons,values,distances,indexes arrays)
/// @param outlats     : returned array of latitudes of the nearest points
/// @param outlons     : returned array of longitudes of the nearest points
/// @param values      : returned array of data values of the nearest points
/// @param distances   : returned array of distances from the nearest points
/// @param indexes     : returned array of indexes of the nearest points
/// @return            0 if OK, integer value on error 
 
 pub fn codes_grib_nearest_find_multiple ( h : * mut codes_handle , is_lsm : :: std :: os :: raw :: c_int , inlats : * mut f64 , inlons : * mut f64 , npoints : :: std :: os :: raw :: c_long , outlats : * mut f64 , outlons : * mut f64 , values : * mut f64 , distances : * mut f64 , indexes : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \defgroup get_set Accessing header and data values   */
/// /*! @{ */
/// /**
/// Get the number offset of a key, in a message if several keys of the same name
/// are present, the offset of the last one is returned
///
/// @param h           : the handle to get the offset from
/// @param key         : the key to be searched
/// @param offset      : the address of a size_t where the offset will be set
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_offset ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , offset : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get the number of coded value from a key, if several keys of the same name are present, the total sum is returned
///
/// @param h           : the handle to get the offset from
/// @param key         : the key to be searched
/// @param size        : the address of a size_t where the size will be set
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_size ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , size : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get the length of the string representation of the key, if several keys of the same name are present, the maximum length is returned
///
/// @param h           : the handle to get the offset from
/// @param key         : the key to be searched
/// @param length        : the address of a size_t where the length will be set
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_length ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get a long value from a key, if several keys of the same name are present, the last one is returned
/// @see  codes_set_long
///
/// @param h           : the handle to get the data from
/// @param key         : the key to be searched
/// @param value       : the address of a long where the data will be retrieved
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_long ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , value : * mut :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get a double value from a key, if several keys of the same name are present, the last one is returned
/// @see  codes_set_double
///
/// @param h           : the handle to get the data from
/// @param key         : the key to be searched
/// @param value       : the address of a double where the data will be retrieved
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_double ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , value : * mut f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get as double the i-th element of the "key" array
///
/// @param h           : the handle to get the data from
/// @param key         : the key to be searched
/// @param i           : zero-based index
/// @param value       : the address of a double where the data will be retrieved
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_double_element ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , i : :: std :: os :: raw :: c_int , value : * mut f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get as double array the elements of the "key" array whose indexes are listed in the input array i
///
/// @param h           : the handle to get the data from
/// @param key         : the key to be searched
/// @param i           : zero-based array of indexes
/// @param size        : size of the i and value arrays
/// @param value       : the double array for the data values
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_double_elements ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , i : * mut :: std :: os :: raw :: c_int , size : :: std :: os :: raw :: c_long , value : * mut f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get a string value from a key, if several keys of the same name are present, the last one is returned
/// @see  codes_set_string
///
/// @param h         : the handle to get the data from
/// @param key       : the key to be searched
/// @param mesg      : the address of a string where the data will be retrieved
/// @param length    : the address of a size_t that contains allocated length of the string on input, and that contains the actual length of the string on output
/// @return          0 if OK, integer value on error 
 
 pub fn codes_get_string ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , mesg : * mut :: std :: os :: raw :: c_char , length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get string array values from a key. If several keys of the same name are present, the last one is returned
/// @see  codes_set_string_array
///
/// @param h       : the handle to get the data from
/// @param key     : the key to be searched
/// @param vals    : the address of a string array where the data will be retrieved
/// @param length  : the address of a size_t that contains allocated length of the array on input, and that contains the actual length of the array on output
/// @return        0 if OK, integer value on error 
 
 pub fn codes_get_string_array ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , vals : * mut * mut :: std :: os :: raw :: c_char , length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get raw bytes values from a key. If several keys of the same name are present, the last one is returned
/// @see  codes_set_bytes
///
/// @param h           : the handle to get the data from
/// @param key         : the key to be searched
/// @param bytes       : the address of a byte array where the data will be retrieved
/// @param length      : the address of a size_t that contains allocated length of the byte array on input, and that contains the actual length of the byte array on output
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_bytes ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , bytes : * mut :: std :: os :: raw :: c_uchar , length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get double array values from a key. If several keys of the same name are present, the last one is returned
/// @see  codes_set_double_array
///
/// @param h        : the handle to get the data from
/// @param key      : the key to be searched
/// @param vals     : the address of a double array where the data will be retrieved
/// @param length   : the address of a size_t that contains allocated length of the double array on input, and that contains the actual length of the double array on output
/// @return         0 if OK, integer value on error 
 
 pub fn codes_get_double_array ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , vals : * mut f64 , length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Get long array values from a key. If several keys of the same name are present, the last one is returned
/// @see  codes_set_long_array
///
/// @param h           : the handle to get the data from
/// @param key         : the key to be searched
/// @param vals       : the address of a long array where the data will be retrieved
/// @param length      : the address of a size_t that contains allocated length of the long array on input, and that contains the actual length of the long array on output
/// @return            0 if OK, integer value on error 
 
 pub fn codes_get_long_array ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , vals : * mut :: std :: os :: raw :: c_long , length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Copy the keys belonging to a given namespace from a source handle to a destination handle
///
///
/// @param dest      : destination handle
/// @param name      : namespace
/// @param src       : source handle
/// @return          0 if OK, integer value on error 
 
 pub fn codes_copy_namespace ( dest : * mut codes_handle , name : * const :: std :: os :: raw :: c_char , src : * mut codes_handle , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Set a long value from a key. If several keys of the same name are present, the last one is set
/// @see  codes_get_long
///
/// @param h           : the handle to set the data to
/// @param key         : the key to be searched
/// @param val         : a long where the data will be read
/// @return            0 if OK, integer value on error 
 
 pub fn codes_set_long ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , val : :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Set a double value from a key. If several keys of the same name are present, the last one is set
/// @see  codes_get_double
///
/// @param h           : the handle to set the data to
/// @param key         : the key to be searched
/// @param val       : a double where the data will be read
/// @return            0 if OK, integer value on error 
 
 pub fn codes_set_double ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , val : f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Set a string value from a key. If several keys of the same name are present, the last one is set
/// @see  codes_get_string
///
/// @param h           : the handle to set the data to
/// @param key         : the key to be searched
/// @param mesg       : the address of a string where the data will be read
/// @param length      : the address of a size_t that contains the length of the string on input, and that contains the actual packed length of the string on output
/// @return            0 if OK, integer value on error 
 
 pub fn codes_set_string ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , mesg : * const :: std :: os :: raw :: c_char , length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Set a bytes array from a key. If several keys of the same name are present, the last one is set
/// @see  codes_get_bytes
///
/// @param h           : the handle to set the data to
/// @param key         : the key to be searched
/// @param bytes       : the address of a byte array where the data will be read
/// @param length      : the address of a size_t that contains the length of the byte array on input, and that contains the actual packed length of the byte array  on output
/// @return            0 if OK, integer value on error 
 
 pub fn codes_set_bytes ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , bytes : * const :: std :: os :: raw :: c_uchar , length : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Set a double array from a key. If several keys of the same name are present, the last one is set
/// @see  codes_get_double_array
///
/// @param h           : the handle to set the data to
/// @param key         : the key to be searched
/// @param vals        : the address of a double array where the data will be read
/// @param length      : a size_t that contains the length of the byte array on input
/// @return            0 if OK, integer value on error 
 
 pub fn codes_set_double_array ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , vals : * const f64 , length : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Same as codes_set_double_array but allows setting of READ-ONLY keys like codedValues.
/// Use with great caution!! 
 
 pub fn codes_set_force_double_array ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , vals : * const f64 , length : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Set a long array from a key. If several keys of the same name are present, the last one is set
/// @see  codes_get_long_array
///
/// @param h           : the handle to set the data to
/// @param key         : the key to be searched
/// @param vals        : the address of a long array where the data will be read
/// @param length      : a size_t that contains the length of the long array on input
/// @return            0 if OK, integer value on error 
 
 pub fn codes_set_long_array ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , vals : * const :: std :: os :: raw :: c_long , length : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Set a string array from a key. If several keys of the same name are present, the last one is set
/// @see  codes_get_long_array
///
/// @param h           : the handle to set the data to
/// @param key         : the key to be searched
/// @param vals        : the address of a string array where the data will be read
/// @param length      : a size_t that contains the length of the array on input
/// @return            0 if OK, integer value on error 
 
 pub fn codes_set_string_array ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , vals : * mut * const :: std :: os :: raw :: c_char , length : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Print all keys, with the context print procedure and dump mode to a resource
///
/// @param h            : the handle to be printed
/// @param out          : output file handle
/// @param mode         : Examples of available dump modes: debug wmo
/// @param option_flags : all the CODES_DUMP_FLAG_x flags can be used
/// @param arg          : used to provide a format to output data (experimental) 
 
 pub fn codes_dump_content ( h : * mut codes_handle , out : * mut FILE , mode : * const :: std :: os :: raw :: c_char , option_flags : :: std :: os :: raw :: c_ulong , arg : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// Print all keys from the parsed definition files available in a context
///
/// @param f           : the File used to print the keys on
/// @param c           : the context that contains the cached definition files to be printed 
 
 pub fn codes_dump_action_tree ( c : * mut codes_context , f : * mut FILE , ) ; 
} extern "C" {
 
 /// Get the static default context
///
/// @return            the default context, NULL it the context is not available 
 
 pub fn codes_context_get_default ( ) -> * mut codes_context ; 
} extern "C" {
 
 /// Frees the cached definition files of the context
///
/// @param c           : the context to be deleted 
 
 pub fn codes_context_delete ( c : * mut codes_context , ) ; 
} extern "C" {
 
 /// Set the GTS header mode on.
/// The GTS headers will be preserved.
///
/// @param c           : the context 
 
 pub fn codes_gts_header_on ( c : * mut codes_context , ) ; 
} extern "C" {
 
 /// Set the GTS header mode off.
/// The GTS headers will be deleted.
///
/// @param c           : the context 
 
 pub fn codes_gts_header_off ( c : * mut codes_context , ) ; 
} extern "C" {
 
 /// Set the GRIBEX mode on.
/// GRIB files will be compatible with GRIBEX.
///
/// @param c           : the context 
 
 pub fn codes_gribex_mode_on ( c : * mut codes_context , ) ; 
} extern "C" {
 
 /// Get the GRIBEX mode.
///
/// @param c           : the context 
 
 pub fn codes_get_gribex_mode ( c : * mut codes_context , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Set the GRIBEX mode off.
/// GRIB files won't be always compatible with GRIBEX.
///
/// @param c           : the context 
 
 pub fn codes_gribex_mode_off ( c : * mut codes_context , ) ; 
} extern "C" {
 
 /// Sets the search path for definition files.
///
/// @param c      : the context to be modified
/// @param path   : the search path for definition files 
 
 pub fn codes_context_set_definitions_path ( c : * mut grib_context , path : * const :: std :: os :: raw :: c_char , ) ; 
} extern "C" {
 
 /// Sets the search path for sample files.
///
/// @param c      : the context to be modified
/// @param path   : the search path for sample files 
 
 pub fn codes_context_set_samples_path ( c : * mut grib_context , path : * const :: std :: os :: raw :: c_char , ) ; 
} extern "C" {
 
 /// Turn on support for multiple fields in single GRIB messages
///
/// @param c            : the context to be modified 
 
 pub fn codes_grib_multi_support_on ( c : * mut codes_context , ) ; 
} extern "C" {
 
 /// Turn off support for multiple fields in single GRIB messages
///
/// @param c            : the context to be modified 
 
 pub fn codes_grib_multi_support_off ( c : * mut codes_context , ) ; 
} extern "C" {
 
 /// Reset file handle in multiple GRIB field support mode
///
/// @param c            : the context to be modified
/// @param f            : the file pointer 
 
 pub fn codes_grib_multi_support_reset_file ( c : * mut codes_context , f : * mut FILE , ) ; 
} extern "C" {
 pub fn codes_samples_path ( c : * const codes_context , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn codes_definition_path ( c : * const codes_context , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 
 /// Get the API version
///
/// @return        API version 
 
 pub fn codes_get_api_version ( ) -> :: std :: os :: raw :: c_long ; 
} extern "C" {
 
 /// Get the Git version control SHA1 identifier
///
/// @return character string with SHA1 identifier 
 
 pub fn codes_get_git_sha1 ( ) -> * const :: std :: os :: raw :: c_char ; 
} extern "C" {
 
 /// Get the package name
///
/// @return character string with package name 
 
 pub fn codes_get_package_name ( ) -> * const :: std :: os :: raw :: c_char ; 
} extern "C" {
 
 /// Prints the API version
/// 
 
 pub fn codes_print_api_version ( out : * mut FILE , ) ; 
} extern "C" {
 
 /// \defgroup keys_iterator Iterating on keys names
/// The keys iterator is designed to get the key names defined in a message.
/// Key names on which the iteration is carried out can be filtered through their
/// attributes or by the namespace they belong to.
/// /
/// /*! @{ */
/// /*! Create a new iterator from a valid and initialised handle.
/// @param h             : the handle whose keys you want to iterate
/// @param filter_flags  : flags to filter out some of the keys through their attributes
/// @param name_space    : if not null the iteration is carried out only on
/// keys belonging to the namespace passed. (NULL for all the keys)
/// @return              keys iterator ready to iterate through keys according to filter_flags
/// and namespace 
 
 pub fn codes_keys_iterator_new ( h : * mut codes_handle , filter_flags : :: std :: os :: raw :: c_ulong , name_space : * const :: std :: os :: raw :: c_char , ) -> * mut codes_keys_iterator ; 
} extern "C" {
 pub fn codes_bufr_copy_data_return_copied_keys ( hin : * mut grib_handle , hout : * mut grib_handle , nkeys : * mut usize , err : * mut :: std :: os :: raw :: c_int , ) -> * mut * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn codes_bufr_copy_data ( hin : * mut grib_handle , hout : * mut grib_handle , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Step to the next item from the keys iterator.
/// @param kiter         : valid codes_keys_iterator
/// @return              1 if next iterator exists, 0 if no more elements to iterate on 
 
 pub fn codes_keys_iterator_next ( kiter : * mut codes_keys_iterator , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// get the key name from the keys iterator
/// @param kiter         : valid codes_keys_iterator
/// @return              key name 
 
 pub fn codes_keys_iterator_get_name ( kiter : * mut codes_keys_iterator , ) -> * const :: std :: os :: raw :: c_char ; 
} extern "C" {
 
 /// Delete the keys iterator.
/// @param kiter         : valid codes_keys_iterator
/// @return              0 if OK, integer value on error 
 
 pub fn codes_keys_iterator_delete ( kiter : * mut codes_keys_iterator , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// Rewind the keys iterator.
/// @param kiter         : valid codes_keys_iterator
/// @return              0 if OK, integer value on error 
 
 pub fn codes_keys_iterator_rewind ( kiter : * mut codes_keys_iterator , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_keys_iterator_set_flags ( kiter : * mut codes_keys_iterator , flags : :: std :: os :: raw :: c_ulong , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_keys_iterator_get_long ( kiter : * mut codes_keys_iterator , v : * mut :: std :: os :: raw :: c_long , len : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_keys_iterator_get_double ( kiter : * mut codes_keys_iterator , v : * mut f64 , len : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_keys_iterator_get_string ( kiter : * mut codes_keys_iterator , v : * mut :: std :: os :: raw :: c_char , len : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_keys_iterator_get_bytes ( kiter : * mut codes_keys_iterator , v : * mut :: std :: os :: raw :: c_uchar , len : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_update_sections_lengths ( h : * mut codes_handle , ) ; 
} extern "C" {
 
 /// Convert an error code into a string
/// @param code       : the error code
/// @return           the error message 
 
 pub fn codes_get_error_message ( code : :: std :: os :: raw :: c_int , ) -> * const :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn codes_get_type_name ( type_ : :: std :: os :: raw :: c_int , ) -> * const :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn codes_get_native_type ( h : * mut codes_handle , name : * const :: std :: os :: raw :: c_char , type_ : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_check ( call : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , e : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , ) ; 
} extern "C" {
 pub fn codes_set_values ( h : * mut codes_handle , codes_values : * mut codes_values , arg_count : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_handle_new_from_partial_message_copy ( c : * mut codes_context , data : * const :: std :: os :: raw :: c_void , size : usize , ) -> * mut codes_handle ; 
} extern "C" {
 pub fn codes_handle_new_from_partial_message ( c : * mut codes_context , data : * const :: std :: os :: raw :: c_void , buflen : usize , ) -> * mut codes_handle ; 
} extern "C" {
 pub fn codes_is_missing ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , err : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_is_defined ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_set_missing ( h : * mut codes_handle , key : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_get_gaussian_latitudes ( truncation : :: std :: os :: raw :: c_long , latitudes : * mut f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_julian_to_datetime ( jd : f64 , year : * mut :: std :: os :: raw :: c_long , month : * mut :: std :: os :: raw :: c_long , day : * mut :: std :: os :: raw :: c_long , hour : * mut :: std :: os :: raw :: c_long , minute : * mut :: std :: os :: raw :: c_long , second : * mut :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_datetime_to_julian ( year : :: std :: os :: raw :: c_long , month : :: std :: os :: raw :: c_long , day : :: std :: os :: raw :: c_long , hour : :: std :: os :: raw :: c_long , minute : :: std :: os :: raw :: c_long , second : :: std :: os :: raw :: c_long , jd : * mut f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_julian_to_date ( jdate : :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_long ; 
} extern "C" {
 pub fn codes_date_to_julian ( ddate : :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_long ; 
} extern "C" {
 pub fn codes_get_reduced_row ( pl : :: std :: os :: raw :: c_long , lon_first : f64 , lon_last : f64 , npoints : * mut :: std :: os :: raw :: c_long , ilon_first : * mut :: std :: os :: raw :: c_long , ilon_last : * mut :: std :: os :: raw :: c_long , ) ; 
} extern "C" {
 pub fn codes_get_reduced_row_p ( pl : :: std :: os :: raw :: c_long , lon_first : f64 , lon_last : f64 , npoints : * mut :: std :: os :: raw :: c_long , olon_first : * mut f64 , olon_last : * mut f64 , ) ; 
} extern "C" {
 pub fn codes_get_message_offset ( h : * mut codes_handle , offset : * mut off_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_get_message_size ( h : * mut codes_handle , size : * mut usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_box_new ( h : * mut codes_handle , error : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_box ; 
} extern "C" {
 pub fn codes_box_get_points ( box_ : * mut codes_box , north : f64 , west : f64 , south : f64 , east : f64 , err : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_points ; 
} extern "C" {
 pub fn codes_points_get_values ( h : * mut codes_handle , points : * mut codes_points , val : * mut f64 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn codes_grib_util_set_spec ( h : * mut codes_handle , grid_spec : * const codes_util_grid_spec , packing_spec : * const codes_util_packing_spec , flags : :: std :: os :: raw :: c_int , data_values : * const f64 , data_values_count : usize , err : * mut :: std :: os :: raw :: c_int , ) -> * mut codes_handle ; 
}